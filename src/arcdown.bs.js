// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var $$Promise = require("@ryyppy/rescript-promise/src/Promise.bs.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Js_string = require("rescript/lib/js/js_string.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

var source = "\n____\nQuote text using\nunderscores\n____\n\n====\nExample block used to\nenclose an example\n====\n";

var alpha = "A-Za-z";

var alnum = "0-9" + alpha;

function getMatches(regex, someline) {
  var result = regex.exec(someline);
  if (result !== null) {
    return Belt_Array.map(result, (function (x) {
                  return Belt_Option.getWithDefault((x == null) ? undefined : Caml_option.some(x), "");
                }));
  } else {
    return [];
  }
}

var EndOfFile = /* @__PURE__ */Caml_exceptions.create("Arcdown.EndOfFile");

var lines = Js_string.split("\n", source);

function nextLine(lnum) {
  var line = Belt_Array.get(lines, lnum);
  if (line === undefined) {
    return Promise.reject({
                RE_EXN_ID: EndOfFile,
                _1: "EOF"
              });
  }
  var trimEnd = /^((\s*[^\s]+)*)\s*$/;
  var match = getMatches(trimEnd, line);
  if (match.length !== 3) {
    return Promise.resolve([
                "",
                lnum + 1 | 0
              ]);
  }
  var line$1 = match[1];
  return Promise.resolve([
              line$1,
              lnum + 1 | 0
            ]);
}

function specialCharsStep(text) {
  var result = Js_string.replaceByRe(/&/g, "&amp;", text);
  var result$1 = Js_string.replaceByRe(/</g, "&lt;", result);
  return Js_string.replaceByRe(/>/g, "&gt;", result$1);
}

function consumeBlockTitle(line) {
  var blockTitleLine = /^\.([^\s].*)$/;
  var match = getMatches(blockTitleLine, line);
  if (match.length !== 2) {
    return [];
  }
  var title = match[1];
  console.log("BLOCKTITLE: " + title);
  return [{
            TAG: /* BlockTitle */8,
            _0: title
          }];
}

function consumeHeading(line) {
  var titleLine = /^(=+)\s+([^\s].*)$/;
  var match = getMatches(titleLine, line);
  if (match.length !== 3) {
    return [];
  }
  var signs = match[1];
  var title = match[2];
  var level = signs.length;
  console.log("HEADING(level " + String(level) + "): " + title);
  return [
          {
            TAG: /* Heading */1,
            _0: level
          },
          {
            TAG: /* Text */0,
            _0: title
          }
        ];
}

function consumeSubstitution(line) {
  var pattern = "^:([" + alpha + "][_" + alnum + "]*(\\.[_" + alnum + "]+)*):\\s+(.*)\$";
  var substLine = new RegExp(pattern);
  var match = getMatches(substLine, line);
  if (match.length !== 4) {
    return [];
  }
  var name = match[1];
  var value = match[3];
  console.log("SUBST: " + name + " --> " + value + "");
  return [
          {
            TAG: /* SubstitutionDef */6,
            _0: name
          },
          {
            TAG: /* Text */0,
            _0: value
          }
        ];
}

function consumeAttribute(line) {
  var attrLine = /^\[\s*([^\[\]]*)\]$/;
  var match = getMatches(attrLine, line);
  if (match.length !== 2) {
    return [];
  }
  var attributes = match[1];
  console.log("ATTR: " + attributes);
  return [{
            TAG: /* Attribute */2,
            _0: attributes
          }];
}

function consumeHyperlink(line) {
  var hlinkLine = /\[\s*([^\]]*)\]\(\s*([^\s\)]*)\s*\)/;
  var match = getMatches(hlinkLine, line);
  if (match.length !== 3) {
    return [];
  }
  var text = match[1];
  var link = match[2];
  console.log("LINK: <" + link + "> with text: '" + text + "'");
  return [
          {
            TAG: /* Hyperlink */7,
            _0: link
          },
          {
            TAG: /* Text */0,
            _0: text
          }
        ];
}

function consumeLabel(line) {
  var labelLine = /^\[\s*([^\]]+)\]:\s*$/;
  var match = getMatches(labelLine, line);
  if (match.length !== 2) {
    return [];
  }
  var label = match[1];
  console.log("LABEL: " + label + "");
  return [{
            TAG: /* Label */5,
            _0: label
          }];
}

function consumeBulletListItem(line) {
  var itemLine = /^\s*([*]+)\s+(.*)$/;
  var match = getMatches(itemLine, line);
  if (match.length !== 3) {
    return [];
  }
  var stars = match[1];
  var text = match[2];
  var level = stars.length;
  console.log("LIST: bullet level " + String(level) + " with text: '" + text + "'");
  return [
          {
            TAG: /* BulletListItem */3,
            _0: level
          },
          {
            TAG: /* Text */0,
            _0: text
          }
        ];
}

function consumeNumberedListItem(line) {
  var itemLine = /^\s*([.]+)\s+(.*)$/;
  var match = getMatches(itemLine, line);
  if (match.length !== 3) {
    return [];
  }
  var dots = match[1];
  var text = match[2];
  var level = dots.length;
  console.log("LIST: item level " + String(level) + " with text: '" + text + "'");
  return [
          {
            TAG: /* NumberedListItem */4,
            _0: level
          },
          {
            TAG: /* Text */0,
            _0: text
          }
        ];
}

function consumeRegularLine(line) {
  var chara = Js_string.charAt(0, line);
  var tok;
  switch (chara) {
    case "*" :
        tok = consumeBulletListItem(line);
        break;
    case "." :
        tok = consumeNumberedListItem(line);
        break;
    case "[" :
        tok = consumeHyperlink(line);
        break;
    default:
      tok = [];
  }
  if (Caml_obj.equal(tok, [])) {
    console.log("TEXT: " + line);
    return [{
              TAG: /* Text */0,
              _0: line
            }];
  } else {
    return tok;
  }
}

var EndOfBlock = /* @__PURE__ */Caml_exceptions.create("Arcdown.EndOfBlock");

function consumeRegularBlock(tok, name, delimiter, line, lnum) {
  if (line !== delimiter) {
    return Promise.resolve([
                tok,
                lnum
              ]);
  }
  var promi = function (param) {
    var lnum = param[2];
    var tok = param[0];
    var match = Belt_List.head(Belt_List.reverse(Belt_List.fromArray(tok)));
    var was_attribute = match !== undefined && !(typeof match === "number" || match.TAG !== /* Attribute */2) ? true : false;
    return $$Promise.$$catch((
                  param[1] ? consumeInitialLine(tok, lnum, was_attribute, delimiter) : consumeLine(tok, lnum, was_attribute, delimiter)
                ).then(promi), (function (err) {
                  if (err.RE_EXN_ID === EndOfBlock) {
                    console.log("BLOCK: " + name + " ended at line " + String(lnum) + "");
                    return Promise.resolve([
                                err._1,
                                lnum + 1 | 0
                              ]);
                  } else if (err.RE_EXN_ID === EndOfFile) {
                    console.log("WARNING: " + name + " block not closed");
                    return Promise.reject(err);
                  } else {
                    console.log("WARNING: Unexpected error");
                    return Promise.reject(err);
                  }
                }));
  };
  return promi([
              tok,
              true,
              lnum
            ]);
}

function consumeInitialLine(tok, lnum, was_attribute, delimiter) {
  return nextLine(lnum).then(function (param) {
              var lnum = param[1];
              var line = param[0];
              if (line === "") {
                return Promise.resolve([
                            tok,
                            true,
                            lnum
                          ]);
              }
              if (!was_attribute && line === delimiter) {
                return Promise.reject({
                            RE_EXN_ID: EndOfBlock,
                            _1: tok
                          });
              }
              var chara = Js_string.charAt(0, line);
              switch (chara) {
                case "*" :
                    return consumeRegularBlock(tok, "Sidebar", "****", line, lnum).then(function (param) {
                                var blocktokens = param[0];
                                if (Caml_obj.equal(blocktokens, [])) {
                                  var tokens = consumeRegularLine(line);
                                  return Promise.resolve([
                                              Belt_Array.concat(tok, tokens),
                                              false,
                                              lnum
                                            ]);
                                }
                                var parts = [
                                  tok,
                                  [/* SidebarBlockDelimiter */4],
                                  blocktokens,
                                  [/* SidebarBlockDelimiter */4]
                                ];
                                return Promise.resolve([
                                            Belt_Array.concatMany(parts),
                                            true,
                                            param[1]
                                          ]);
                              });
                case "." :
                    var tokens = consumeBlockTitle(line);
                    if (tokens.length === 1) {
                      var title = tokens[0];
                      if (typeof title !== "number" && title.TAG === /* BlockTitle */8) {
                        return Promise.resolve([
                                    Belt_Array.concat(tok, tokens),
                                    true,
                                    lnum
                                  ]);
                      }
                      
                    }
                    if (!Caml_obj.equal(tokens, [])) {
                      throw {
                            RE_EXN_ID: "Assert_failure",
                            _1: [
                              "arcdown.res",
                              285,
                              10
                            ],
                            Error: new Error()
                          };
                    }
                    var tokens$1 = consumeRegularLine(line);
                    return Promise.resolve([
                                Belt_Array.concat(tok, tokens$1),
                                false,
                                lnum
                              ]);
                case ":" :
                    var tokens$2 = consumeSubstitution(line);
                    if (tokens$2.length === 2) {
                      var name = tokens$2[0];
                      if (typeof name !== "number" && name.TAG === /* SubstitutionDef */6) {
                        var value = tokens$2[1];
                        if (typeof value !== "number" && value.TAG === /* Text */0) {
                          return Promise.resolve([
                                      Belt_Array.concat(tok, tokens$2),
                                      true,
                                      lnum
                                    ]);
                        }
                        
                      }
                      
                    }
                    if (!Caml_obj.equal(tokens$2, [])) {
                      throw {
                            RE_EXN_ID: "Assert_failure",
                            _1: [
                              "arcdown.res",
                              312,
                              10
                            ],
                            Error: new Error()
                          };
                    }
                    return Promise.resolve([
                                consumeRegularLine(line),
                                false,
                                lnum
                              ]);
                case "=" :
                    var tokens$3 = consumeHeading(line);
                    if (Caml_obj.notequal(tokens$3, [])) {
                      return Promise.resolve([
                                  Belt_Array.concat(tok, tokens$3),
                                  false,
                                  lnum
                                ]);
                    } else {
                      return consumeRegularBlock(tok, "Example", "====", line, lnum).then(function (param) {
                                  var blocktokens = param[0];
                                  if (Caml_obj.equal(blocktokens, [])) {
                                    var tokens = consumeRegularLine(line);
                                    return Promise.resolve([
                                                Belt_Array.concat(tok, tokens),
                                                false,
                                                lnum
                                              ]);
                                  }
                                  var parts = [
                                    tok,
                                    [/* ExampleBlockDelimiter */2],
                                    blocktokens,
                                    [/* ExampleBlockDelimiter */2]
                                  ];
                                  return Promise.resolve([
                                              Belt_Array.concatMany(parts),
                                              true,
                                              param[1]
                                            ]);
                                });
                    }
                case "[" :
                    var tokens$4 = consumeAttribute(line);
                    if (tokens$4.length === 1) {
                      var attributes = tokens$4[0];
                      if (typeof attributes !== "number" && attributes.TAG === /* Attribute */2) {
                        return Promise.resolve([
                                    Belt_Array.concat(tok, tokens$4),
                                    true,
                                    lnum
                                  ]);
                      }
                      
                    }
                    if (!Caml_obj.equal(tokens$4, [])) {
                      throw {
                            RE_EXN_ID: "Assert_failure",
                            _1: [
                              "arcdown.res",
                              320,
                              10
                            ],
                            Error: new Error()
                          };
                    }
                    var tokens$5 = consumeLabel(line);
                    if (Caml_obj.notequal(tokens$5, [])) {
                      return Promise.resolve([
                                  Belt_Array.concat(tok, tokens$5),
                                  true,
                                  lnum
                                ]);
                    }
                    var tokens$6 = consumeRegularLine(line);
                    return Promise.resolve([
                                Belt_Array.concat(tok, tokens$6),
                                false,
                                lnum
                              ]);
                    break;
                case "_" :
                    return consumeRegularBlock(tok, "Quote", "____", line, lnum).then(function (param) {
                                var blocktokens = param[0];
                                if (Caml_obj.equal(blocktokens, [])) {
                                  var tokens = consumeRegularLine(line);
                                  return Promise.resolve([
                                              Belt_Array.concat(tok, tokens),
                                              false,
                                              lnum
                                            ]);
                                }
                                var parts = [
                                  tok,
                                  [/* QuoteBlockDelimiter */3],
                                  blocktokens,
                                  [/* QuoteBlockDelimiter */3]
                                ];
                                return Promise.resolve([
                                            Belt_Array.concatMany(parts),
                                            true,
                                            param[1]
                                          ]);
                              });
                default:
                  var tokens$7 = consumeRegularLine(line);
                  return Promise.resolve([
                              Belt_Array.concat(tok, tokens$7),
                              false,
                              lnum
                            ]);
              }
            });
}

function consumeLine(tok, lnum, was_attribute, delimiter) {
  return nextLine(lnum).then(function (param) {
              var lnum = param[1];
              var line = param[0];
              if (line === "") {
                console.log("<empty>");
                return Promise.resolve([
                            tok,
                            true,
                            lnum
                          ]);
              }
              if (!was_attribute && line === delimiter) {
                return Promise.reject({
                            RE_EXN_ID: EndOfBlock,
                            _1: tok
                          });
              }
              var chara = Js_string.charAt(0, line);
              if (chara === "[") {
                var tokens = consumeAttribute(line);
                if (tokens.length === 1) {
                  var attributes = tokens[0];
                  if (typeof attributes !== "number" && attributes.TAG === /* Attribute */2) {
                    return Promise.resolve([
                                Belt_Array.concat(tok, tokens),
                                true,
                                lnum
                              ]);
                  }
                  
                }
                if (!Caml_obj.equal(tokens, [])) {
                  throw {
                        RE_EXN_ID: "Assert_failure",
                        _1: [
                          "arcdown.res",
                          373,
                          10
                        ],
                        Error: new Error()
                      };
                }
                var tokens$1 = consumeRegularLine(line);
                return Promise.resolve([
                            Belt_Array.concat(tok, tokens$1),
                            false,
                            lnum
                          ]);
              }
              var tokens$2 = consumeRegularLine(line);
              return Promise.resolve([
                          Belt_Array.concat(tok, tokens$2),
                          false,
                          lnum
                        ]);
            });
}

var Success = /* @__PURE__ */Caml_exceptions.create("Arcdown.Success");

function promi(param) {
  var lnum = param[2];
  var tok = param[0];
  var match = Belt_List.head(Belt_List.reverse(Belt_List.fromArray(tok)));
  var was_attribute = match !== undefined && !(typeof match === "number" || match.TAG !== /* Attribute */2) ? true : false;
  return $$Promise.$$catch($$Promise.$$catch($$Promise.$$catch(param[1] ? consumeInitialLine(tok, lnum, was_attribute, "") : consumeLine(tok, lnum, was_attribute, ""), (function ($$event) {
                          if ($$event.RE_EXN_ID === EndOfFile) {
                            return Promise.reject({
                                        RE_EXN_ID: Success,
                                        _1: tok
                                      });
                          } else {
                            return Promise.reject($$event);
                          }
                        })), (function (err) {
                      if (err.RE_EXN_ID === Success) {
                        var tokens = err._1;
                        Belt_Array.forEach(tokens, (function (token) {
                                console.log("T: ", token);
                              }));
                        console.log("DONE " + String(tokens.length) + "");
                        return Promise.reject(err);
                      }
                      console.log("Unexpected error");
                      return Promise.reject(err);
                    })).then(promi), (function (param) {
                return Promise.resolve(undefined);
              }));
}

promi([
      [],
      true,
      0
    ]);

var backtick = "`";

var spaces = "      ";

var outputFormat = /* Html */0;

var subs = /* [] */0;

var attrs = "";

var lnum = 0;

exports.backtick = backtick;
exports.spaces = spaces;
exports.source = source;
exports.alpha = alpha;
exports.alnum = alnum;
exports.getMatches = getMatches;
exports.EndOfFile = EndOfFile;
exports.lines = lines;
exports.nextLine = nextLine;
exports.outputFormat = outputFormat;
exports.specialCharsStep = specialCharsStep;
exports.consumeBlockTitle = consumeBlockTitle;
exports.consumeHeading = consumeHeading;
exports.consumeSubstitution = consumeSubstitution;
exports.consumeAttribute = consumeAttribute;
exports.consumeHyperlink = consumeHyperlink;
exports.consumeLabel = consumeLabel;
exports.consumeBulletListItem = consumeBulletListItem;
exports.consumeNumberedListItem = consumeNumberedListItem;
exports.consumeRegularLine = consumeRegularLine;
exports.EndOfBlock = EndOfBlock;
exports.consumeRegularBlock = consumeRegularBlock;
exports.consumeInitialLine = consumeInitialLine;
exports.consumeLine = consumeLine;
exports.subs = subs;
exports.attrs = attrs;
exports.lnum = lnum;
exports.Success = Success;
exports.promi = promi;
/* lines Not a pure module */
