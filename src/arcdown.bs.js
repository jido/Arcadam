// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var $$Promise = require("@ryyppy/rescript-promise/src/Promise.bs.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Js_string = require("rescript/lib/js/js_string.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Belt_HashMapString = require("rescript/lib/js/belt_HashMapString.js");

var backtick = "`";

var source = "\n[NOTE]\n====\nThis is how to start a new example\nblock within this block:\n\n[example]\n====\n.Nested block<\nA small example\n====\n====\n\n:subs: value&more\n== Arcdown Test ->> part 1\n\n[Go to " + backtick + "Products page" + backtick + " on this site](/Products.html)\n\n[Go to _Offers page_ in current path](Offers.html)\n\n[Go to an arbitrary webpage](https://www.github.com)\n\n[#anchor]:\nPart 1: This text is selected by the anchor.\n\n[<Go to *Part 1*>](#anchor)\n\n____\nQuote text using\nunderscores\n____\n\n====\nExample block used to\nenclose an example\n====\n\n****\nSidebar block used to\nexpand on a topic or\nhighlight an idea\n****\n\n* First<\nmulti line\n* Second&&\n** sublist\n** one more\n  ... nested numbered list\n  ... nested 2\n* Third\n[list]\n. Number one\n  Indented text without\n  line breaks is added\n  to a code block\n\n----\nAnother way to create\na code block delimited\nwith \"----\"\n\n****\nThis is not a new block\n----\n\n[:begin region]:\nThis text can be included\non its own.\n[:end region]:\nNew block starts after label\n";

var alpha = "A-Za-z";

var alnum = "0-9" + alpha;

function getMatches(regex, someline) {
  var result = regex.exec(someline);
  if (result !== null) {
    return Belt_Array.map(result, (function (x) {
                  var __x = (x == null) ? undefined : Caml_option.some(x);
                  return Belt_Option.getWithDefault(__x, "");
                }));
  } else {
    return [];
  }
}

var EndOfFile = /* @__PURE__ */Caml_exceptions.create("Arcdown.EndOfFile");

var lines = Js_string.split("\n", source);

function nextLine(lnum) {
  var line = Belt_Array.get(lines, lnum);
  if (line === undefined) {
    return Promise.reject({
                RE_EXN_ID: EndOfFile,
                _1: "EOF"
              });
  }
  var trimEnd = /^((\s*[^\s]+)*)\s*$/;
  var match = getMatches(trimEnd, line);
  if (match.length !== 3) {
    return Promise.resolve([
                "",
                lnum + 1 | 0
              ]);
  }
  var line$1 = match[1];
  return Promise.resolve([
              line$1,
              lnum + 1 | 0
            ]);
}

function specialCharsStep(text) {
  var result = Js_string.replaceByRe(/&/g, "&amp;", text);
  var result$1 = Js_string.replaceByRe(/</g, "&lt;", result);
  return Js_string.replaceByRe(/>/g, "&gt;", result$1);
}

function consumeBlockTitle(line) {
  var blockTitleLine = /^\.([^\s].*)$/;
  var match = getMatches(blockTitleLine, line);
  if (match.length !== 2) {
    return [];
  }
  var title = match[1];
  return [{
            TAG: "BlockTitle",
            _0: title
          }];
}

function consumeHeading(line) {
  var titleLine = /^(=+)\s+([^\s].*)$/;
  var match = getMatches(titleLine, line);
  if (match.length !== 3) {
    return [];
  }
  var signs = match[1];
  var title = match[2];
  var level = signs.length;
  return [
          {
            TAG: "Heading",
            _0: level
          },
          {
            TAG: "Text",
            _0: title
          }
        ];
}

function consumeSubstitution(line) {
  var pattern = "^:([" + alpha + "][_" + alnum + "]*(\\.[_" + alnum + "]+)*):\\s+(.*)\$";
  var substLine = new RegExp(pattern);
  var match = getMatches(substLine, line);
  if (match.length !== 4) {
    return [];
  }
  var name = match[1];
  var value = match[3];
  return [
          {
            TAG: "SubstitutionDef",
            _0: name
          },
          {
            TAG: "Text",
            _0: value
          }
        ];
}

function consumeAttribute(line) {
  var attrLine = /^\[\s*([^\[\]]*)\]$/;
  var match = getMatches(attrLine, line);
  if (match.length !== 2) {
    return [];
  }
  var attributes = match[1];
  return [{
            TAG: "Attribute",
            _0: attributes
          }];
}

function consumeHyperlink(line) {
  var hlinkLine = /\[\s*([^\]]*)\]\(\s*([^\s\)]*)\s*\)/;
  var match = getMatches(hlinkLine, line);
  if (match.length !== 3) {
    return [];
  }
  var text = match[1];
  var link = match[2];
  return [
          {
            TAG: "Hyperlink",
            _0: link
          },
          {
            TAG: "Text",
            _0: text
          }
        ];
}

function consumeLabel(line) {
  var labelLine = /^\[\s*([^\]]+)\]:\s*$/;
  var match = getMatches(labelLine, line);
  if (match.length !== 2) {
    return [];
  }
  var label = match[1];
  return [{
            TAG: "Label",
            _0: label
          }];
}

function consumeBulletListItem(line) {
  var itemLine = /^\s*([*]+)\s+(.*)$/;
  var match = getMatches(itemLine, line);
  if (match.length !== 3) {
    return [];
  }
  var stars = match[1];
  var text = match[2];
  var level = stars.length;
  var match$1 = Js_string.charAt(0, line);
  if (match$1 === "*") {
    return [
            {
              TAG: "BulletListItem",
              _0: level
            },
            {
              TAG: "Text",
              _0: text
            }
          ];
  } else {
    return [
            {
              TAG: "IndentedBulletListItem",
              _0: level
            },
            {
              TAG: "IndentedText",
              _0: text
            }
          ];
  }
}

function consumeNumberedListItem(line) {
  var itemLine = /^\s*([.]+)\s+(.*)$/;
  var match = getMatches(itemLine, line);
  if (match.length !== 3) {
    return [];
  }
  var dots = match[1];
  var text = match[2];
  var level = dots.length;
  var match$1 = Js_string.charAt(0, line);
  if (match$1 === ".") {
    return [
            {
              TAG: "NumberedListItem",
              _0: level
            },
            {
              TAG: "Text",
              _0: text
            }
          ];
  } else {
    return [
            {
              TAG: "IndentedNumberedListItem",
              _0: level
            },
            {
              TAG: "IndentedText",
              _0: text
            }
          ];
  }
}

function consumeBlockDelimiter(line) {
  switch (line) {
    case "" :
        return ["Empty"];
    case "****" :
        return ["SidebarBlockDelimiter"];
    case "--" :
        return ["FreeBlockDelimiter"];
    case "----" :
        return ["CodeBlockDelimiter"];
    case "====" :
        return ["ExampleBlockDelimiter"];
    case "____" :
        return ["QuoteBlockDelimiter"];
    default:
      return [];
  }
}

function consumeRegularLine(line) {
  var chara = Js_string.charAt(0, line);
  var tok;
  var exit = 0;
  switch (chara) {
    case "*" :
        tok = consumeBulletListItem(line);
        break;
    case "." :
        tok = consumeNumberedListItem(line);
        break;
    case "[" :
        tok = consumeHyperlink(line);
        break;
    case " " :
    case "\t" :
        exit = 1;
        break;
    default:
      tok = [];
  }
  if (exit === 1) {
    var tokens = consumeBulletListItem(line);
    if (Caml_obj.equal(tokens, [])) {
      var tokens$1 = consumeNumberedListItem(line);
      tok = Caml_obj.equal(tokens$1, []) ? [{
            TAG: "IndentedText",
            _0: line
          }] : tokens$1;
    } else {
      tok = tokens;
    }
  }
  if (Caml_obj.equal(tok, [])) {
    return [{
              TAG: "Text",
              _0: line
            }];
  } else {
    return tok;
  }
}

var EndOfBlock = /* @__PURE__ */Caml_exceptions.create("Arcdown.EndOfBlock");

function consumeInitialLine(tok, lnum) {
  return nextLine(lnum).then(function (param) {
              var lnum = param[1];
              var line = param[0];
              var tokens = consumeBlockDelimiter(line);
              if (tokens.length !== 1) {
                var chara = Js_string.charAt(0, line);
                switch (chara) {
                  case "." :
                      var tokens$1 = consumeBlockTitle(line);
                      if (tokens$1.length === 1) {
                        var _title = tokens$1[0];
                        if (typeof _title === "object" && _title.TAG === "BlockTitle") {
                          return Promise.resolve([
                                      Belt_Array.concat(tok, tokens$1),
                                      "Initial",
                                      lnum
                                    ]);
                        }
                        
                      }
                      if (!Caml_obj.equal(tokens$1, [])) {
                        throw {
                              RE_EXN_ID: "Assert_failure",
                              _1: [
                                "arcdown.res",
                                277,
                                12
                              ],
                              Error: new Error()
                            };
                      }
                      var tokens$2 = consumeRegularLine(line);
                      return Promise.resolve([
                                  Belt_Array.concat(tok, tokens$2),
                                  "Following",
                                  lnum
                                ]);
                  case ":" :
                      var tokens$3 = consumeSubstitution(line);
                      if (tokens$3.length === 2) {
                        var _name = tokens$3[0];
                        if (typeof _name === "object" && _name.TAG === "SubstitutionDef") {
                          var _value = tokens$3[1];
                          if (typeof _value === "object" && _value.TAG === "Text") {
                            return Promise.resolve([
                                        Belt_Array.concat(tok, tokens$3),
                                        "Initial",
                                        lnum
                                      ]);
                          }
                          
                        }
                        
                      }
                      if (!Caml_obj.equal(tokens$3, [])) {
                        throw {
                              RE_EXN_ID: "Assert_failure",
                              _1: [
                                "arcdown.res",
                                296,
                                12
                              ],
                              Error: new Error()
                            };
                      }
                      return Promise.resolve([
                                  consumeRegularLine(line),
                                  "Following",
                                  lnum
                                ]);
                  case "=" :
                      var tokens$4 = consumeHeading(line);
                      if (Caml_obj.notequal(tokens$4, [])) {
                        return Promise.resolve([
                                    Belt_Array.concat(tok, tokens$4),
                                    "Following",
                                    lnum
                                  ]);
                      }
                      var tokens$5 = consumeRegularLine(line);
                      return Promise.resolve([
                                  Belt_Array.concat(tok, tokens$5),
                                  "Following",
                                  lnum
                                ]);
                  case "[" :
                      var tokens$6 = consumeAttribute(line);
                      if (tokens$6.length === 1) {
                        var _attributes = tokens$6[0];
                        if (typeof _attributes === "object" && _attributes.TAG === "Attribute") {
                          return Promise.resolve([
                                      Belt_Array.concat(tok, tokens$6),
                                      "Following",
                                      lnum
                                    ]);
                        }
                        
                      }
                      if (!Caml_obj.equal(tokens$6, [])) {
                        throw {
                              RE_EXN_ID: "Assert_failure",
                              _1: [
                                "arcdown.res",
                                304,
                                12
                              ],
                              Error: new Error()
                            };
                      }
                      var tokens$7 = consumeLabel(line);
                      if (Caml_obj.notequal(tokens$7, [])) {
                        return Promise.resolve([
                                    Belt_Array.concat(tok, tokens$7),
                                    "Initial",
                                    lnum
                                  ]);
                      }
                      var tokens$8 = consumeRegularLine(line);
                      return Promise.resolve([
                                  Belt_Array.concat(tok, tokens$8),
                                  "Following",
                                  lnum
                                ]);
                      break;
                  default:
                    var tokens$9 = consumeRegularLine(line);
                    return Promise.resolve([
                                Belt_Array.concat(tok, tokens$9),
                                "Following",
                                lnum
                              ]);
                }
              } else {
                var match = tokens[0];
                if (typeof match !== "object" && match === "CodeBlockDelimiter") {
                  return Promise.resolve([
                              Belt_Array.concat(tok, tokens),
                              "Code",
                              lnum
                            ]);
                }
                return Promise.resolve([
                            Belt_Array.concat(tok, tokens),
                            "Initial",
                            lnum
                          ]);
              }
            });
}

function consumeLine(tok, lnum) {
  return nextLine(lnum).then(function (param) {
              var lnum = param[1];
              var line = param[0];
              var tokens = consumeBlockDelimiter(line);
              if (tokens.length !== 0) {
                return Promise.resolve([
                            Belt_Array.concat(tok, tokens),
                            "Initial",
                            lnum
                          ]);
              }
              var tokens$1 = consumeAttribute(line);
              var exit = 0;
              if (tokens$1.length !== 1) {
                exit = 1;
              } else {
                var _attributes = tokens$1[0];
                if (typeof _attributes !== "object") {
                  exit = 1;
                } else {
                  if (_attributes.TAG === "Attribute") {
                    return Promise.resolve([
                                Belt_Array.concat(tok, tokens$1),
                                "Following",
                                lnum
                              ]);
                  }
                  exit = 1;
                }
              }
              if (exit === 1) {
                if (!Caml_obj.equal(tokens$1, [])) {
                  throw {
                        RE_EXN_ID: "Assert_failure",
                        _1: [
                          "arcdown.res",
                          331,
                          8
                        ],
                        Error: new Error()
                      };
                }
                var tokens$2 = consumeLabel(line);
                var exit$1 = 0;
                if (tokens$2.length !== 1) {
                  exit$1 = 2;
                } else {
                  var _label = tokens$2[0];
                  if (typeof _label !== "object") {
                    exit$1 = 2;
                  } else {
                    if (_label.TAG === "Label") {
                      return Promise.resolve([
                                  Belt_Array.concat(tok, tokens$2),
                                  "Initial",
                                  lnum
                                ]);
                    }
                    exit$1 = 2;
                  }
                }
                if (exit$1 === 2) {
                  if (!Caml_obj.equal(tokens$2, [])) {
                    throw {
                          RE_EXN_ID: "Assert_failure",
                          _1: [
                            "arcdown.res",
                            336,
                            10
                          ],
                          Error: new Error()
                        };
                  }
                  var tokens$3 = consumeRegularLine(line);
                  return Promise.resolve([
                              Belt_Array.concat(tok, tokens$3),
                              "Following",
                              lnum
                            ]);
                }
                
              }
              
            });
}

function consumeCodeLine(tok, lnum) {
  return nextLine(lnum).then(function (param) {
              var lnum = param[1];
              var line = param[0];
              if (line === "----") {
                return Promise.resolve([
                            Belt_Array.concat(tok, ["CodeBlockDelimiter"]),
                            "Initial",
                            lnum
                          ]);
              } else {
                return Promise.resolve([
                            Belt_Array.concat(tok, [{
                                    TAG: "CodeText",
                                    _0: line
                                  }]),
                            "Code",
                            lnum
                          ]);
              }
            });
}

function parseAttribute(atext) {
  var pattern = "^\\s*([.]?[" + alpha + "]([.]?[" + alnum + "])*)";
  var attrExpr = new RegExp(pattern);
  var k = getMatches(attrExpr, atext);
  if (k.length !== 3) {
    console.log("Failed to parse:", k);
    return ;
  }
  var name = k[1];
  console.log("Parse: attribute", name);
}

function parseLabel(atext) {
  var pattern = "^\\s*([:#^>]?[" + alpha + "]([" + alnum + "])*)";
  var labelExpr = new RegExp(pattern);
  var k = getMatches(labelExpr, atext);
  if (k.length !== 3) {
    console.log("Failed to parse:", k);
    return ;
  }
  var name = k[1];
  console.log("Parse: label", name);
}

function parseDocument(tok) {
  Belt_HashMapString.make(10);
  Belt_HashMapString.make(30);
  Belt_Array.forEach(tok, (function (token) {
          if (typeof token !== "object") {
            return ;
          }
          switch (token.TAG) {
            case "Attribute" :
                return parseAttribute(token._0);
            case "Label" :
                return parseLabel(token._0);
            default:
              return ;
          }
        }));
}

var Success = /* @__PURE__ */Caml_exceptions.create("Arcdown.Success");

function promi(param) {
  var lnum = param[2];
  var tok = param[0];
  var tmp;
  switch (param[1]) {
    case "Initial" :
        tmp = consumeInitialLine(tok, lnum);
        break;
    case "Following" :
        tmp = consumeLine(tok, lnum);
        break;
    case "Code" :
        tmp = consumeCodeLine(tok, lnum);
        break;
    
  }
  return $$Promise.$$catch(tmp.then(promi), (function (err) {
                if (err.RE_EXN_ID === EndOfFile) {
                  Belt_Array.forEach(tok, (function (token) {
                          console.log("T: ", token);
                        }));
                  console.log("DONE " + String(tok.length));
                  parseDocument(tok);
                  return Promise.resolve(undefined);
                } else {
                  console.log("Unexpected error");
                  return Promise.resolve(undefined);
                }
              }));
}

promi([
      [],
      "Initial",
      0
    ]);

var outputFormat = "Html";

var subs = /* [] */0;

var attrs = "";

var lnum = 0;

exports.backtick = backtick;
exports.source = source;
exports.alpha = alpha;
exports.alnum = alnum;
exports.getMatches = getMatches;
exports.EndOfFile = EndOfFile;
exports.lines = lines;
exports.nextLine = nextLine;
exports.outputFormat = outputFormat;
exports.specialCharsStep = specialCharsStep;
exports.consumeBlockTitle = consumeBlockTitle;
exports.consumeHeading = consumeHeading;
exports.consumeSubstitution = consumeSubstitution;
exports.consumeAttribute = consumeAttribute;
exports.consumeHyperlink = consumeHyperlink;
exports.consumeLabel = consumeLabel;
exports.consumeBulletListItem = consumeBulletListItem;
exports.consumeNumberedListItem = consumeNumberedListItem;
exports.consumeBlockDelimiter = consumeBlockDelimiter;
exports.consumeRegularLine = consumeRegularLine;
exports.EndOfBlock = EndOfBlock;
exports.consumeInitialLine = consumeInitialLine;
exports.consumeLine = consumeLine;
exports.consumeCodeLine = consumeCodeLine;
exports.parseAttribute = parseAttribute;
exports.parseLabel = parseLabel;
exports.parseDocument = parseDocument;
exports.subs = subs;
exports.attrs = attrs;
exports.lnum = lnum;
exports.Success = Success;
exports.promi = promi;
/* lines Not a pure module */
