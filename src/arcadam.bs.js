// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Core__Promise = require("@rescript/core/src/Core__Promise.bs.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

var backtick = "`";

var source = "\n[NOTE]\n====\nThis is how to start a new example\nblock within this block:\n\n[example]\n====\nNested block<\nA small example\n====\n====\n\n:key:subs value&more\n## Arcadam Test ->> part 1\n\n[Go to " + backtick + "Products page" + backtick + " on this site](/Products.html)\n\n[Go to _Offers page_ in current path](Offers.html)\n\n[Go to an arbitrary webpage](https://www.github.com)\n\n[#anchor]:\nPart 1: This text is selected by the anchor.\n\n[<Go to *Part 1*>](#anchor)\n\n[Arcadam Test ->> part 1]()\n\n___\nQuote text using\nunderscores\n___\n\n====\nExample block used to\nenclose an example\n====\n\n****\nSidebar block used to\nexpand on a topic or\nhighlight an idea\n****\n\nParagraph:\n* First<\nmulti line\n* Second&&\n> * first sublist\n>   > ** sublist\n>>    ** one more\n    >  1... nested numbered list\n      on two lines\n      ... nested 2\n..\n    That was all for first sublist.\n* Third\n[list]\n. Number one\n\n= Block title\n" + backtick + backtick + backtick + "\nunindented code block\n  indented line inside code block\n" + backtick + backtick + backtick + "\n\n  Indented text is added\n  * to a code block\n\n  code block continued\n\n// comment\n\n\tAnother code block\n\n" + backtick + backtick + backtick + "\nAnother way to create\na code block delimited\nwith " + backtick + backtick + backtick + "\n\n****\nThis is not a new block\n" + backtick + backtick + backtick + "\n\n[-begin region]:\nThis text can be included\non its own.\n[-end region]:\nNew block starts after marker\n\n[.styleclass]\n[mylist.first]\nTesting dotted attributes\n";

var alpha = "A-Za-z";

var alnum = "0-9" + alpha;

function getMatches(regex, someline) {
  var result = regex.exec(someline);
  if (result == null) {
    return [];
  } else {
    return result.slice(1);
  }
}

function countSpaces(line) {
  var spacesIndent = /^([ ]+)/;
  var match = getMatches(spacesIndent, line);
  if (match.length !== 1) {
    return 0;
  } else {
    return match[0].length;
  }
}

var EndOfFile = /* @__PURE__ */Caml_exceptions.create("Arcadam.EndOfFile");

var lines = source.split("\n");

function nextLine(lnum) {
  var line = lines[lnum];
  if (line === undefined) {
    return Promise.reject({
                RE_EXN_ID: EndOfFile,
                _1: "EOF"
              });
  }
  var count = countSpaces(line);
  return Promise.resolve([
              line.trim(),
              lnum + 1 | 0,
              count
            ]);
}

function specialCharsStep(text) {
  var result = text.replaceAll(/&/g, "&amp;");
  var result$1 = result.replaceAll(/</g, "&lt;");
  return result$1.replaceAll(/>/g, "&gt;");
}

function consumeIndentSigns(line) {
  var indentSign = /^((>\s*)*>\s+)/;
  var match = getMatches(indentSign, line);
  if (match.length !== 2) {
    return [];
  }
  var indent = match[0];
  var onlySigns = indent.replaceAll(/\s+/g, "");
  return [{
            TAG: "IndentSigns",
            _0: onlySigns.length,
            _1: indent.length
          }];
}

function consumeBlockTitle(line) {
  var blockTitleLine = /^=\s+(.*)$/;
  var match = getMatches(blockTitleLine, line);
  if (match.length !== 1) {
    return [];
  }
  var title = match[0];
  return [{
            TAG: "BlockTitle",
            _0: title
          }];
}

function consumeHeading(line) {
  var titleLine = /^(#+)\s+([^\s].*)$/;
  var match = getMatches(titleLine, line);
  if (match.length !== 2) {
    return [];
  }
  var signs = match[0];
  var title = match[1];
  var level = signs.length;
  return [
          {
            TAG: "Heading",
            _0: level
          },
          {
            TAG: "Text",
            _0: title
          }
        ];
}

function consumeReplacement(line) {
  var pattern = "^:key:([" + alpha + "][_" + alnum + "]*(\\.[_" + alnum + "]+)*)\\s+(.*)\$";
  var substLine = new RegExp(pattern);
  var match = getMatches(substLine, line);
  if (match.length !== 3) {
    return [];
  }
  var name = match[0];
  var value = match[2];
  return [
          {
            TAG: "ReplacementKey",
            _0: name
          },
          {
            TAG: "Text",
            _0: value
          }
        ];
}

function consumeAttribute(line) {
  var attrLine = /^\[\s*([^\[\]]*)\]$/;
  var match = getMatches(attrLine, line);
  if (match.length !== 1) {
    return [];
  }
  var attributes = match[0];
  return [{
            TAG: "Attribute",
            _0: attributes
          }];
}

function consumeHyperlink(line) {
  var hlinkLine = /\[\s*([^\]]*)\]\(\s*([^\s\)]*)\s*\)/;
  var match = getMatches(hlinkLine, line);
  if (match.length !== 2) {
    return [];
  }
  var text = match[0];
  var link = match[1];
  return [
          {
            TAG: "Hyperlink",
            _0: link
          },
          {
            TAG: "Text",
            _0: text
          }
        ];
}

function consumeMarker(line) {
  var markerLine = /^\[\s*([^\]]+)\]:\s*$/;
  var match = getMatches(markerLine, line);
  if (match.length !== 1) {
    return [];
  }
  var marker = match[0];
  return [{
            TAG: "Marker",
            _0: marker
          }];
}

function consumeBulletListItem(line) {
  var itemLine = /^([*]+)\s+(.*)$/;
  var match = getMatches(itemLine, line);
  if (match.length !== 2) {
    return [];
  }
  var stars = match[0];
  var text = match[1];
  var level = stars.length;
  return [
          {
            TAG: "BulletListItem",
            _0: level
          },
          {
            TAG: "Text",
            _0: text
          }
        ];
}

function consumeNumberedListItem(line) {
  var itemLine = /^1?([.]+)\s+(.*)$/;
  var match = getMatches(itemLine, line);
  if (match.length !== 2) {
    return [];
  }
  var dots = match[0];
  var text = match[1];
  var level = dots.length;
  return [
          {
            TAG: "NumberedListItem",
            _0: level
          },
          {
            TAG: "Text",
            _0: text
          }
        ];
}

function consumeNestingSigns(line) {
  var itemLine = /^([.]+)\s*$/;
  var match = getMatches(itemLine, line);
  if (match.length !== 1) {
    return [];
  }
  var dots = match[0];
  var level = dots.length;
  return [{
            TAG: "Nesting",
            _0: level
          }];
}

function consumeBlockDelimiter(line) {
  switch (line) {
    case "" :
        return ["Empty"];
    case "****" :
        return ["SidebarBlockDelimiter"];
    case "--" :
        return ["FreeBlockDelimiter"];
    case "====" :
        return ["ExampleBlockDelimiter"];
    case "___" :
        return ["QuoteBlockDelimiter"];
    case "```" :
        return ["CodeBlockDelimiter"];
    case "~~~~" :
        return ["ContentBlockDelimiter"];
    default:
      return [];
  }
}

function consumeRegularLine(line) {
  var chara = line.charAt(0);
  var tok;
  switch (chara) {
    case "*" :
        tok = consumeBulletListItem(line);
        break;
    case "." :
        var nesting = consumeNestingSigns(line);
        if (nesting.length !== 1) {
          tok = consumeNumberedListItem(line);
        } else {
          var _level = nesting[0];
          tok = typeof _level !== "object" || _level.TAG !== "Nesting" ? consumeNumberedListItem(line) : nesting;
        }
        break;
    case ">" :
        var indents = consumeIndentSigns(line);
        if (indents.length !== 1) {
          tok = [{
              TAG: "Text",
              _0: line
            }];
        } else {
          var match = indents[0];
          if (typeof match !== "object") {
            tok = [{
                TAG: "Text",
                _0: line
              }];
          } else if (match.TAG === "IndentSigns") {
            var rest = line.slice(match._1);
            tok = indents.concat(consumeRegularLine(rest));
          } else {
            tok = [{
                TAG: "Text",
                _0: line
              }];
          }
        }
        break;
    case "[" :
        tok = consumeHyperlink(line);
        break;
    default:
      tok = [];
  }
  if (Caml_obj.equal(tok, [])) {
    return [{
              TAG: "Text",
              _0: line
            }];
  } else {
    return tok;
  }
}

var EndOfBlock = /* @__PURE__ */Caml_exceptions.create("Arcadam.EndOfBlock");

function tokeniseInitialLine(line, tok, lnum) {
  var tokens = consumeBlockDelimiter(line);
  if (tokens.length !== 1) {
    var chara = line.charAt(0);
    switch (chara) {
      case "#" :
          var tokens$1 = consumeHeading(line);
          if (Caml_obj.notequal(tokens$1, [])) {
            return Promise.resolve([
                        tok.concat(tokens$1),
                        "Following",
                        lnum
                      ]);
          }
          var tokens$2 = consumeRegularLine(line);
          return Promise.resolve([
                      tok.concat(tokens$2),
                      "Following",
                      lnum
                    ]);
      case ":" :
          var tokens$3 = consumeReplacement(line);
          if (tokens$3.length === 2) {
            var _name = tokens$3[0];
            if (typeof _name === "object" && _name.TAG === "ReplacementKey") {
              var _value = tokens$3[1];
              if (typeof _value === "object" && _value.TAG === "Text") {
                return Promise.resolve([
                            tok.concat(tokens$3),
                            "Initial",
                            lnum
                          ]);
              }
              
            }
            
          }
          if (!Caml_obj.equal(tokens$3, [])) {
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "arcadam.res",
                    342,
                    10
                  ],
                  Error: new Error()
                };
          }
          return Promise.resolve([
                      consumeRegularLine(line),
                      "Following",
                      lnum
                    ]);
      case "=" :
          var tokens$4 = consumeBlockTitle(line);
          if (tokens$4.length === 1) {
            var _title = tokens$4[0];
            if (typeof _title === "object" && _title.TAG === "BlockTitle") {
              return Promise.resolve([
                          tok.concat(tokens$4),
                          "Initial",
                          lnum
                        ]);
            }
            
          }
          if (!Caml_obj.equal(tokens$4, [])) {
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "arcadam.res",
                    323,
                    10
                  ],
                  Error: new Error()
                };
          }
          var tokens$5 = consumeRegularLine(line);
          return Promise.resolve([
                      tok.concat(tokens$5),
                      "Following",
                      lnum
                    ]);
      case "[" :
          var tokens$6 = consumeAttribute(line);
          if (tokens$6.length === 1) {
            var _attributes = tokens$6[0];
            if (typeof _attributes === "object" && _attributes.TAG === "Attribute") {
              return Promise.resolve([
                          tok.concat(tokens$6),
                          "Following",
                          lnum
                        ]);
            }
            
          }
          if (!Caml_obj.equal(tokens$6, [])) {
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "arcadam.res",
                    350,
                    10
                  ],
                  Error: new Error()
                };
          }
          var tokens$7 = consumeMarker(line);
          if (Caml_obj.notequal(tokens$7, [])) {
            return Promise.resolve([
                        tok.concat(tokens$7),
                        "Initial",
                        lnum
                      ]);
          }
          var tokens$8 = consumeRegularLine(line);
          return Promise.resolve([
                      tok.concat(tokens$8),
                      "Following",
                      lnum
                    ]);
          break;
      default:
        var tokens$9 = consumeRegularLine(line);
        return Promise.resolve([
                    tok.concat(tokens$9),
                    "Following",
                    lnum
                  ]);
    }
  } else {
    var match = tokens[0];
    if (typeof match !== "object" && match === "CodeBlockDelimiter") {
      return Promise.resolve([
                  tok.concat(tokens),
                  "Code",
                  lnum
                ]);
    }
    return Promise.resolve([
                tok.concat(tokens),
                "Initial",
                lnum
              ]);
  }
}

function consumeInitialLine(tok, lnum) {
  return nextLine(lnum).then(function (param) {
              var nspaces = param[2];
              var lnum = param[1];
              var line = param[0];
              if (nspaces <= 0) {
                return tokeniseInitialLine(line, tok, lnum);
              }
              var tokens = [
                {
                  TAG: "Spaces",
                  _0: nspaces
                },
                {
                  TAG: "IndentedCode",
                  _0: line
                }
              ];
              return Promise.resolve([
                          tok.concat(tokens),
                          "Indented",
                          lnum
                        ]);
            });
}

function consumeLine(tok, lnum) {
  return nextLine(lnum).then(function (param) {
              var nspaces = param[2];
              var lnum = param[1];
              var line = param[0];
              var tok$1 = nspaces > 0 ? tok.concat([{
                        TAG: "Spaces",
                        _0: nspaces
                      }]) : tok;
              var tokens = consumeBlockDelimiter(line);
              if (tokens.length !== 0) {
                return Promise.resolve([
                            tok$1.concat(tokens),
                            "Initial",
                            lnum
                          ]);
              }
              var tokens$1 = consumeAttribute(line);
              var exit = 0;
              if (tokens$1.length !== 1) {
                exit = 1;
              } else {
                var _attributes = tokens$1[0];
                if (typeof _attributes !== "object") {
                  exit = 1;
                } else {
                  if (_attributes.TAG === "Attribute") {
                    return Promise.resolve([
                                tok$1.concat(tokens$1),
                                "Following",
                                lnum
                              ]);
                  }
                  exit = 1;
                }
              }
              if (exit === 1) {
                if (!Caml_obj.equal(tokens$1, [])) {
                  throw {
                        RE_EXN_ID: "Assert_failure",
                        _1: [
                          "arcadam.res",
                          388,
                          8
                        ],
                        Error: new Error()
                      };
                }
                var tokens$2 = consumeMarker(line);
                var exit$1 = 0;
                if (tokens$2.length !== 1) {
                  exit$1 = 2;
                } else {
                  var _marker = tokens$2[0];
                  if (typeof _marker !== "object") {
                    exit$1 = 2;
                  } else {
                    if (_marker.TAG === "Marker") {
                      return Promise.resolve([
                                  tok$1.concat(tokens$2),
                                  "Initial",
                                  lnum
                                ]);
                    }
                    exit$1 = 2;
                  }
                }
                if (exit$1 === 2) {
                  if (!Caml_obj.equal(tokens$2, [])) {
                    throw {
                          RE_EXN_ID: "Assert_failure",
                          _1: [
                            "arcadam.res",
                            393,
                            10
                          ],
                          Error: new Error()
                        };
                  }
                  var tokens$3 = consumeRegularLine(line);
                  return Promise.resolve([
                              tok$1.concat(tokens$3),
                              "Following",
                              lnum
                            ]);
                }
                
              }
              
            });
}

function consumeCodeLine(tok, lnum) {
  return nextLine(lnum).then(function (param) {
              var nspaces = param[2];
              var lnum = param[1];
              var line = param[0];
              var tok$1 = nspaces > 0 ? tok.concat([{
                        TAG: "Spaces",
                        _0: nspaces
                      }]) : tok;
              if (line === "```") {
                return Promise.resolve([
                            tok$1.concat(["CodeBlockDelimiter"]),
                            "Initial",
                            lnum
                          ]);
              } else {
                return Promise.resolve([
                            tok$1.concat([{
                                    TAG: "CodeText",
                                    _0: line
                                  }]),
                            "Code",
                            lnum
                          ]);
              }
            });
}

function consumeIndentedCode(tok, lnum) {
  return nextLine(lnum).then(function (param) {
              var nspaces = param[2];
              var lnum = param[1];
              var line = param[0];
              if (nspaces <= 0) {
                return tokeniseInitialLine(line, tok, lnum);
              }
              var tokens = [
                {
                  TAG: "Spaces",
                  _0: nspaces
                },
                {
                  TAG: "IndentedCode",
                  _0: line
                }
              ];
              return Promise.resolve([
                          tok.concat(tokens),
                          "Indented",
                          lnum
                        ]);
            });
}

function consumeListLine(tok, lnum) {
  return nextLine(lnum).then(function (param) {
              var nspaces = param[2];
              var lnum = param[1];
              var line = param[0];
              var tok$1 = nspaces > 0 ? tok.concat([{
                        TAG: "Spaces",
                        _0: nspaces
                      }]) : tok;
              if (line === "") {
                return consumeInitialLine(tok$1.concat(["Empty"]), lnum);
              }
              var tokens = consumeBulletListItem(line);
              if (!Caml_obj.equal(tokens, [])) {
                return Promise.resolve([
                            tok$1.concat(tokens),
                            "List",
                            lnum
                          ]);
              }
              var tokens$1 = consumeNumberedListItem(line);
              if (Caml_obj.equal(tokens$1, [])) {
                return Promise.resolve([
                            tok$1.concat([{
                                    TAG: "Text",
                                    _0: line
                                  }]),
                            "List",
                            lnum
                          ]);
              } else {
                return Promise.resolve([
                            tok$1.concat(tokens$1),
                            "List",
                            lnum
                          ]);
              }
            });
}

function parseAttribute(atext, attributes) {
  var pattern = "^\\s*([.]?[" + alpha + "]([.]?[" + alnum + "])*)";
  var attrExpr = new RegExp(pattern);
  var k = getMatches(attrExpr, atext);
  if (k.length !== 2) {
    console.log("Failed to parse:", k);
    return ;
  }
  var name = k[0];
  console.log("Parse: attribute", name);
  attributes.set(name, "");
}

function parseMarker(atext) {
  var pattern = "^\\s*([!-@[-" + backtick + "|~][" + alpha + "]([" + alnum + "])*)";
  var markerExpr = new RegExp(pattern);
  var k = getMatches(markerExpr, atext);
  if (k.length !== 2) {
    console.log("Failed to parse:", k);
    return ;
  }
  var name = k[0];
  console.log("Parse: marker", name);
}

function parseDocument(tok) {
  var _attributes = new Map();
  var _substitutions = new Map();
  var state = {
    contents: "General"
  };
  tok.forEach(function (token) {
        if (typeof token !== "object") {
          return ;
        }
        switch (token.TAG) {
          case "Text" :
              var value = token._0;
              var name = state.contents;
              if (typeof name !== "object") {
                return ;
              }
              var name$1 = name._0;
              console.log("Parse: will replace reference", name$1, "with", value);
              state.contents = "General";
              _substitutions.set(name$1, value);
              return ;
          case "Attribute" :
              return parseAttribute(token._0, _attributes);
          case "Marker" :
              return parseMarker(token._0);
          case "ReplacementKey" :
              state.contents = {
                TAG: "Replacement",
                _0: token._0
              };
              return ;
          default:
            return ;
        }
      });
}

var Success = /* @__PURE__ */Caml_exceptions.create("Arcadam.Success");

function promi(param) {
  var lnum = param[2];
  var tok = param[0];
  var tmp;
  switch (param[1]) {
    case "Initial" :
        tmp = consumeInitialLine(tok, lnum);
        break;
    case "Following" :
        tmp = consumeLine(tok, lnum);
        break;
    case "Code" :
        tmp = consumeCodeLine(tok, lnum);
        break;
    case "Indented" :
        tmp = consumeIndentedCode(tok, lnum);
        break;
    case "List" :
        tmp = consumeListLine(tok, lnum);
        break;
    
  }
  return Core__Promise.$$catch(tmp.then(promi), (function (err) {
                if (err.RE_EXN_ID === EndOfFile) {
                  tok.forEach(function (token) {
                        console.log("T: ", token);
                      });
                  console.log("DONE " + String(tok.length));
                  parseDocument(tok);
                  return Promise.resolve();
                } else {
                  console.log("Unexpected error");
                  return Promise.resolve();
                }
              }));
}

promi([
      [],
      "Initial",
      0
    ]);

var outputFormat = "Html";

var subs = /* [] */0;

var attrs = "";

var lnum = 0;

exports.backtick = backtick;
exports.source = source;
exports.alpha = alpha;
exports.alnum = alnum;
exports.getMatches = getMatches;
exports.countSpaces = countSpaces;
exports.EndOfFile = EndOfFile;
exports.lines = lines;
exports.nextLine = nextLine;
exports.outputFormat = outputFormat;
exports.specialCharsStep = specialCharsStep;
exports.consumeIndentSigns = consumeIndentSigns;
exports.consumeBlockTitle = consumeBlockTitle;
exports.consumeHeading = consumeHeading;
exports.consumeReplacement = consumeReplacement;
exports.consumeAttribute = consumeAttribute;
exports.consumeHyperlink = consumeHyperlink;
exports.consumeMarker = consumeMarker;
exports.consumeBulletListItem = consumeBulletListItem;
exports.consumeNumberedListItem = consumeNumberedListItem;
exports.consumeNestingSigns = consumeNestingSigns;
exports.consumeBlockDelimiter = consumeBlockDelimiter;
exports.consumeRegularLine = consumeRegularLine;
exports.EndOfBlock = EndOfBlock;
exports.tokeniseInitialLine = tokeniseInitialLine;
exports.consumeInitialLine = consumeInitialLine;
exports.consumeLine = consumeLine;
exports.consumeCodeLine = consumeCodeLine;
exports.consumeIndentedCode = consumeIndentedCode;
exports.consumeListLine = consumeListLine;
exports.parseAttribute = parseAttribute;
exports.parseMarker = parseMarker;
exports.parseDocument = parseDocument;
exports.subs = subs;
exports.attrs = attrs;
exports.lnum = lnum;
exports.Success = Success;
exports.promi = promi;
/* lines Not a pure module */
